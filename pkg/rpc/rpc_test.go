package rpc_test

import (
	"context"
	"errors"
	"fmt"
	"net"
	"testing"
	"time"

	"github.com/bxcodec/faker/v3"
	"github.com/google/uuid"
	"github.com/robotlovesyou/fitest/pb"
	"github.com/robotlovesyou/fitest/pkg/rpc"
	"github.com/robotlovesyou/fitest/pkg/users"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/status"
)

// I have coded a stub/mock of the UsersService, because the code generated by mockgen makes me sad

type stubCreateUser func(context.Context, users.NewUser) (users.User, error)
type stubUpdateUser func(context.Context, users.UserUpdate) (users.User, error)
type stubDeleteUser func(context.Context, users.UserRef) error

type stubUsersService struct {
	createUser stubCreateUser
	updateUser stubUpdateUser
	deleteUser stubDeleteUser
}

func newStubService() *stubUsersService {
	return &stubUsersService{
		createUser: func(context.Context, users.NewUser) (users.User, error) {
			panic("stub create user")
		},
		updateUser: func(context.Context, users.UserUpdate) (users.User, error) {
			panic("stub update user")
		},
		deleteUser: func(context.Context, users.UserRef) error {
			panic("stub delete user")
		},
	}
}

func (svc *stubUsersService) CreateUser(ctx context.Context, newUser users.NewUser) (users.User, error) {
	return svc.createUser(ctx, newUser)
}

func (svc *stubUsersService) UpdateUser(ctx context.Context, userUpdate users.UserUpdate) (users.User, error) {
	return svc.updateUser(ctx, userUpdate)
}

func (svc *stubUsersService) DeleteUser(ctx context.Context, userRef users.UserRef) error {
	return svc.deleteUser(ctx, userRef)
}

// end of UsersService mock

// fakeNewUser creates new users using faker for testing
func fakeNewUser() pb.NewUser {
	password := faker.Password()
	return pb.NewUser{
		FirstName:       faker.FirstName(),
		LastName:        faker.LastName(),
		Nickname:        faker.Username(),
		Password:        password,
		ConfirmPassword: password,
		Email:           faker.Email(),
		Country:         "DE",
	}
}

func fakeUserUpdate() pb.UserUpdate {
	password := faker.Password()
	return pb.UserUpdate{
		Id:              uuid.Must(uuid.NewRandom()).String(),
		FirstName:       faker.FirstName(),
		LastName:        faker.LastName(),
		Password:        password,
		ConfirmPassword: password,
		Country:         "DE",
		Version:         0,
	}
}

func fakeUserRef() pb.UserRef {
	return pb.UserRef{
		Id: uuid.Must(uuid.NewRandom()).String(),
	}
}

// userFromNewUser creates a fake user from a new user for testing
func userFromNewUser(newUser users.NewUser) users.User {
	return users.User{
		ID:           uuid.Must(uuid.NewRandom()),
		FirstName:    newUser.FirstName,
		LastName:     newUser.LastName,
		Nickname:     newUser.Nickname,
		PasswordHash: "HashOfASuperSecretPassword",
		Email:        newUser.Email,
		Country:      newUser.Country,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}
}

func userFromUserUpdate(userUpdate users.UserUpdate) users.User {
	return users.User{
		ID:           uuid.Must(uuid.NewRandom()),
		FirstName:    userUpdate.FirstName,
		LastName:     userUpdate.LastName,
		Email:        faker.Email(),
		Nickname:     faker.Username(),
		PasswordHash: "HashOfASuperSecretPassword",
		Country:      userUpdate.Country,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}
}

// withClient creates and instantiates a grpc server which delegates calls to the provided
// rpc.UsersService imlementation, and calls the callback f with a client connected to the
// grpc server
func withClient(svc rpc.UsersService, f func(pb.UsersClient)) {
	lis, err := net.Listen("tcp", "localhost:0")
	if err != nil {
		panic(fmt.Sprintf("cannot open random port: %v", err))
	}
	serverAddress := lis.Addr().String()

	grpcServer := grpc.NewServer()
	pb.RegisterUsersServer(grpcServer, rpc.New(svc))
	go grpcServer.Serve(lis)
	defer grpcServer.Stop()

	conn, err := grpc.Dial(serverAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		panic(fmt.Sprintf("cannot dial rpc server: %v", err))
	}
	defer conn.Close()
	client := pb.NewUsersClient(conn)
	f(client)
}

func TestCreateUserRPCCallsUsersServiceWithCorrectValues(t *testing.T) {
	stubService := newStubService()
	request := fakeNewUser()
	var response users.User
	withClient(stubService, func(client pb.UsersClient) {
		// check that the request payload has been conveyed correctly to the users service
		stubService.createUser = func(ctx context.Context, newUser users.NewUser) (users.User, error) {
			require.Equal(t, request.FirstName, newUser.FirstName)
			require.Equal(t, request.LastName, newUser.LastName)
			require.Equal(t, request.Nickname, newUser.Nickname)
			require.Equal(t, request.Password, newUser.Password)
			require.Equal(t, request.ConfirmPassword, newUser.ConfirmPassword)
			require.Equal(t, request.Email, newUser.Email)
			require.Equal(t, request.Country, newUser.Country)
			response = userFromNewUser(newUser)
			return response, nil
		}

		// check that the created user has been conveyed correctly via the rpc layer
		user, err := client.CreateUser(context.Background(), &request)
		require.NoError(t, err)
		require.Equal(t, response.ID.String(), user.Id)
		require.Equal(t, response.FirstName, user.FirstName)
		require.Equal(t, response.LastName, user.LastName)
		require.Equal(t, response.Nickname, user.Nickname)
		require.Equal(t, response.Email, user.Email)
		require.Equal(t, response.Country, user.Country)
		require.Equal(t, response.CreatedAt.Format(time.RFC3339), user.CreatedAt)
		require.Equal(t, response.UpdatedAt.Format(time.RFC3339), user.UpdatedAt)
	})
}

func TestCorrectErrorCodesSentCreatingUser(t *testing.T) {
	// For the sake of brevity, I am only going to use grpc error codes when the service fails.
	// In a real world implementation I would, where appropriate, include detail via status details
	cases := []struct {
		name         string
		result       error
		expectedCode codes.Code
	}{
		{
			name:         "Already exists",
			result:       users.ErrAlreadyExists,
			expectedCode: codes.AlreadyExists,
		},
		{
			name:         "Invalid",
			result:       users.ErrInvalid,
			expectedCode: codes.InvalidArgument,
		},
		{
			name:         "Internal",
			result:       errors.New("some unexpected error"),
			expectedCode: codes.Internal,
		},
	}
	for _, testCase := range cases {
		t.Run(testCase.name, func(t *testing.T) {
			stubService := newStubService()
			request := fakeNewUser()
			withClient(stubService, func(client pb.UsersClient) {
				stubService.createUser = func(ctx context.Context, _ users.NewUser) (usr users.User, err error) {
					return usr, testCase.result
				}

				_, err := client.CreateUser(context.Background(), &request)
				require.Equal(t, testCase.expectedCode.String(), status.Code(err).String())
			})
		})
	}
}

func TestUpdateUserRPCCallsServiceWithCorrectValues(t *testing.T) {
	stubService := newStubService()
	request := fakeUserUpdate()
	var response users.User
	withClient(stubService, func(client pb.UsersClient) {
		// check that the request payload has been conveyed correctly to the users service
		stubService.updateUser = func(ctx context.Context, userUpdate users.UserUpdate) (users.User, error) {
			require.Equal(t, request.Id, userUpdate.ID)
			require.Equal(t, request.FirstName, userUpdate.FirstName)
			require.Equal(t, request.LastName, userUpdate.LastName)
			require.Equal(t, request.Password, userUpdate.Password)
			require.Equal(t, request.ConfirmPassword, userUpdate.ConfirmPassword)

			require.Equal(t, request.Country, userUpdate.Country)
			response = userFromUserUpdate(userUpdate)
			return response, nil
		}

		// check that the created user has been conveyed correctly via the rpc layer
		user, err := client.UpdateUser(context.Background(), &request)
		require.NoError(t, err)
		require.Equal(t, response.ID.String(), user.Id)
		require.Equal(t, response.FirstName, user.FirstName)
		require.Equal(t, response.LastName, user.LastName)
		require.Equal(t, response.Nickname, user.Nickname)
		require.Equal(t, response.Email, user.Email)
		require.Equal(t, response.Country, user.Country)
		require.Equal(t, response.CreatedAt.Format(time.RFC3339), user.CreatedAt)
		require.Equal(t, response.UpdatedAt.Format(time.RFC3339), user.UpdatedAt)
	})
}

func TestCorrectErrorCodesSentUpdatingUser(t *testing.T) {
	// For the sake of brevity, I am only going to use grpc error codes when the service fails.
	// In a real world implementation I would, where appropriate, include detail via status details
	cases := []struct {
		name         string
		result       error
		expectedCode codes.Code
	}{
		{
			name:         "NotFound",
			result:       users.ErrNotFound,
			expectedCode: codes.NotFound,
		},
		{
			name:         "Invalid",
			result:       users.ErrInvalid,
			expectedCode: codes.InvalidArgument,
		},
		{
			name:         "InvalidVersion",
			result:       users.ErrInvalidVersion,
			expectedCode: codes.FailedPrecondition,
		},
		{
			name:         "Internal",
			result:       errors.New("some unexpected error"),
			expectedCode: codes.Internal,
		},
	}
	for _, testCase := range cases {
		t.Run(testCase.name, func(t *testing.T) {
			stubService := newStubService()
			request := fakeUserUpdate()
			withClient(stubService, func(client pb.UsersClient) {
				stubService.updateUser = func(ctx context.Context, _ users.UserUpdate) (usr users.User, err error) {
					return usr, testCase.result
				}

				_, err := client.UpdateUser(context.Background(), &request)
				require.Equal(t, testCase.expectedCode.String(), status.Code(err).String())
			})
		})
	}
}

func TestDeleteUserRPCCallsUsersServiceWithCorrectValues(t *testing.T) {
	stubService := newStubService()
	request := fakeUserRef()
	withClient(stubService, func(client pb.UsersClient) {
		// check that the request payload has been conveyed correctly to the users service
		stubService.deleteUser = func(ctx context.Context, ref users.UserRef) error {
			require.Equal(t, request.Id, ref.ID)
			return nil
		}

		// check that the created user has been conveyed correctly via the rpc layer
		_, err := client.DeleteUser(context.Background(), &request)
		require.NoError(t, err)
	})
}

func TestCorrectErrorCodesSentDeletingUser(t *testing.T) {
	// For the sake of brevity, I am only going to use grpc error codes when the service fails.
	// In a real world implementation I would, where appropriate, include detail via status details
	cases := []struct {
		name         string
		result       error
		expectedCode codes.Code
	}{
		{
			name:         "NotFound",
			result:       users.ErrNotFound,
			expectedCode: codes.NotFound,
		},
		{
			name:         "Invalid", // invalid could be returned if the id is malformed and cannot be parsed as a UUID
			result:       users.ErrInvalid,
			expectedCode: codes.InvalidArgument,
		},
		{
			name:         "Internal",
			result:       errors.New("some unexpected error"),
			expectedCode: codes.Internal,
		},
	}
	for _, testCase := range cases {
		t.Run(testCase.name, func(t *testing.T) {
			stubService := newStubService()
			request := fakeUserRef()
			withClient(stubService, func(client pb.UsersClient) {
				stubService.deleteUser = func(ctx context.Context, _ users.UserRef) error {
					return testCase.result
				}

				_, err := client.DeleteUser(context.Background(), &request)
				require.Equal(t, testCase.expectedCode.String(), status.Code(err).String())
			})
		})
	}
}
