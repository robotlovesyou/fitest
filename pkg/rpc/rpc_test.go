package rpc_test

import (
	"context"
	"errors"
	"fmt"
	"net"
	"testing"
	"time"

	"github.com/bxcodec/faker/v3"
	"github.com/google/uuid"
	"github.com/robotlovesyou/fitest/pkg/rpc"
	"github.com/robotlovesyou/fitest/pkg/user"
	"github.com/robotlovesyou/fitest/userspb"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/status"
)

// I have coded a stub/mock of the UsersService, because the code generated by mockgen makes me sad

type stubCreateUser func(context.Context, user.NewUser) (user.User, error)
type stubUpdateUser func(context.Context, user.Update) (user.User, error)
type stubDeleteUser func(context.Context, user.Ref) error
type stubFindUsers func(context.Context, user.Query) (user.Page, error)

type stubUsersService struct {
	createUser stubCreateUser
	updateUser stubUpdateUser
	deleteUser stubDeleteUser
	findUsers  stubFindUsers
}

func newStubService() *stubUsersService {
	return &stubUsersService{
		createUser: func(context.Context, user.NewUser) (user.User, error) {
			panic("stub create user")
		},
		updateUser: func(context.Context, user.Update) (user.User, error) {
			panic("stub update user")
		},
		deleteUser: func(context.Context, user.Ref) error {
			panic("stub delete user")
		},
		findUsers: func(context.Context, user.Query) (user.Page, error) {
			panic("stub find users")
		},
	}
}

func (svc *stubUsersService) CreateUser(ctx context.Context, newUser user.NewUser) (user.User, error) {
	return svc.createUser(ctx, newUser)
}

func (svc *stubUsersService) UpdateUser(ctx context.Context, userUpdate user.Update) (user.User, error) {
	return svc.updateUser(ctx, userUpdate)
}

func (svc *stubUsersService) DeleteUser(ctx context.Context, userRef user.Ref) error {
	return svc.deleteUser(ctx, userRef)
}

func (svc stubUsersService) FindUsers(ctx context.Context, query user.Query) (user.Page, error) {
	return svc.findUsers(ctx, query)
}

// end of UsersService mock

// fakeNewUser creates new users using faker for testing
func fakeNewUser() userspb.NewUser {
	password := faker.Password()
	return userspb.NewUser{
		FirstName:       faker.FirstName(),
		LastName:        faker.LastName(),
		Nickname:        faker.Username(),
		Password:        password,
		ConfirmPassword: password,
		Email:           faker.Email(),
		Country:         "DE",
	}
}

func fakeUserUpdate() userspb.Update {
	password := faker.Password()
	return userspb.Update{
		Id:              uuid.Must(uuid.NewRandom()).String(),
		FirstName:       faker.FirstName(),
		LastName:        faker.LastName(),
		Password:        password,
		ConfirmPassword: password,
		Country:         "DE",
		Version:         0,
	}
}

func fakeUserRef() userspb.Ref {
	return userspb.Ref{
		Id: uuid.Must(uuid.NewRandom()).String(),
	}
}

func fakeUsersQuery() userspb.Query {
	return userspb.Query{
		CreatedAfter: time.Now().Format(user.TimeFormat),
		Country:      "DE",
		Length:       10,
		Page:         11,
	}
}

func fakeUser() user.User {
	return user.User{
		ID:           uuid.Must(uuid.NewRandom()),
		FirstName:    faker.FirstName(),
		LastName:     faker.LastName(),
		Nickname:     faker.Username(),
		PasswordHash: "HashOfASuperSecretPassword",
		Email:        faker.Email(),
		Country:      "DE",
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}
}

// userFromNewUser creates a fake user from a new user for testing
func userFromNewUser(newUser user.NewUser) user.User {
	return user.User{
		ID:           uuid.Must(uuid.NewRandom()),
		FirstName:    newUser.FirstName,
		LastName:     newUser.LastName,
		Nickname:     newUser.Nickname,
		PasswordHash: "HashOfASuperSecretPassword",
		Email:        newUser.Email,
		Country:      newUser.Country,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}
}

func userFromUserUpdate(userUpdate user.Update) user.User {
	return user.User{
		ID:           uuid.Must(uuid.NewRandom()),
		FirstName:    userUpdate.FirstName,
		LastName:     userUpdate.LastName,
		Email:        faker.Email(),
		Nickname:     faker.Username(),
		PasswordHash: "HashOfASuperSecretPassword",
		Country:      userUpdate.Country,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}
}

func usersPageFromQuery(query user.Query) user.Page {
	items := make([]user.User, 0, query.Length)
	for i := 0; i < int(query.Length); i += 1 {
		items = append(items, fakeUser())
	}
	return user.Page{
		Page:  query.Page,
		Total: query.Page * query.Length,
		Items: items,
	}
}

func compareUserToPBUser(t *testing.T, usr user.User, pbUser *userspb.User) {
	require.Equal(t, usr.ID.String(), pbUser.Id)
	require.Equal(t, usr.FirstName, pbUser.FirstName)
	require.Equal(t, usr.LastName, pbUser.LastName)
	require.Equal(t, usr.Nickname, pbUser.Nickname)
	require.Equal(t, usr.Email, pbUser.Email)
	require.Equal(t, usr.Country, pbUser.Country)
	require.Equal(t, usr.CreatedAt.Format(user.TimeFormat), pbUser.CreatedAt)
	require.Equal(t, usr.UpdatedAt.Format(user.TimeFormat), pbUser.UpdatedAt)
}

// withClient creates and instantiates a grpc server which delegates calls to the provided
// rpc.UsersService imlementation, and calls the callback f with a client connected to the
// grpc server
func withClient(svc rpc.UsersService, f func(userspb.UsersClient)) {
	lis, err := net.Listen("tcp", "localhost:0")
	if err != nil {
		panic(fmt.Sprintf("cannot open random port: %v", err))
	}
	serverAddress := lis.Addr().String()

	grpcServer := grpc.NewServer()
	userspb.RegisterUsersServer(grpcServer, rpc.New(svc))
	go grpcServer.Serve(lis)
	defer grpcServer.Stop()

	conn, err := grpc.Dial(serverAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		panic(fmt.Sprintf("cannot dial rpc server: %v", err))
	}
	defer conn.Close()
	client := userspb.NewUsersClient(conn)
	f(client)
}

func TestCreateUserRPCCallsUsersServiceWithCorrectValues(t *testing.T) {
	stubService := newStubService()
	request := fakeNewUser()
	var response user.User
	withClient(stubService, func(client userspb.UsersClient) {
		// check that the request payload has been conveyed correctly to the users service
		stubService.createUser = func(ctx context.Context, newUser user.NewUser) (user.User, error) {
			require.Equal(t, request.FirstName, newUser.FirstName)
			require.Equal(t, request.LastName, newUser.LastName)
			require.Equal(t, request.Nickname, newUser.Nickname)
			require.Equal(t, request.Password, newUser.Password)
			require.Equal(t, request.ConfirmPassword, newUser.ConfirmPassword)
			require.Equal(t, request.Email, newUser.Email)
			require.Equal(t, request.Country, newUser.Country)
			response = userFromNewUser(newUser)
			return response, nil
		}

		// check that the created user has been conveyed correctly via the rpc layer
		user, err := client.CreateUser(context.Background(), &request)
		require.NoError(t, err)
		compareUserToPBUser(t, response, user)
	})
}

func TestCorrectErrorCodesSentCreatingUser(t *testing.T) {
	// For the sake of brevity, I am only going to use grpc error codes when the service fails.
	// In a real world implementation I would, where appropriate, include detail via status details
	cases := []struct {
		name         string
		result       error
		expectedCode codes.Code
	}{
		{
			name:         "Already exists",
			result:       user.ErrAlreadyExists,
			expectedCode: codes.AlreadyExists,
		},
		{
			name:         "Invalid",
			result:       user.ErrInvalid,
			expectedCode: codes.InvalidArgument,
		},
		{
			name:         "Internal",
			result:       errors.New("some unexpected error"),
			expectedCode: codes.Internal,
		},
	}
	for _, testCase := range cases {
		t.Run(testCase.name, func(t *testing.T) {
			stubService := newStubService()
			request := fakeNewUser()
			withClient(stubService, func(client userspb.UsersClient) {
				stubService.createUser = func(ctx context.Context, _ user.NewUser) (usr user.User, err error) {
					return usr, testCase.result
				}

				_, err := client.CreateUser(context.Background(), &request)
				require.Equal(t, testCase.expectedCode.String(), status.Code(err).String())
			})
		})
	}
}

func TestUpdateUserRPCCallsServiceAndRespondsWithCorrectValues(t *testing.T) {
	stubService := newStubService()
	request := fakeUserUpdate()
	var response user.User
	withClient(stubService, func(client userspb.UsersClient) {
		// check that the request payload has been conveyed correctly to the users service
		stubService.updateUser = func(ctx context.Context, userUpdate user.Update) (user.User, error) {
			require.Equal(t, request.Id, userUpdate.ID)
			require.Equal(t, request.FirstName, userUpdate.FirstName)
			require.Equal(t, request.LastName, userUpdate.LastName)
			require.Equal(t, request.Password, userUpdate.Password)
			require.Equal(t, request.ConfirmPassword, userUpdate.ConfirmPassword)

			require.Equal(t, request.Country, userUpdate.Country)
			response = userFromUserUpdate(userUpdate)
			return response, nil
		}

		// check that the updated user has been conveyed correctly via the rpc layer
		user, err := client.UpdateUser(context.Background(), &request)
		require.NoError(t, err)
		compareUserToPBUser(t, response, user)
	})
}

func TestCorrectErrorCodesSentUpdatingUser(t *testing.T) {
	// For the sake of brevity, I am only going to use grpc error codes when the service fails.
	// In a real world implementation I would, where appropriate, include detail via status details
	cases := []struct {
		name         string
		result       error
		expectedCode codes.Code
	}{
		{
			name:         "NotFound",
			result:       user.ErrNotFound,
			expectedCode: codes.NotFound,
		},
		{
			name:         "Invalid",
			result:       user.ErrInvalid,
			expectedCode: codes.InvalidArgument,
		},
		{
			name:         "InvalidVersion",
			result:       user.ErrInvalidVersion,
			expectedCode: codes.FailedPrecondition,
		},
		{
			name:         "Internal",
			result:       errors.New("some unexpected error"),
			expectedCode: codes.Internal,
		},
	}
	for _, testCase := range cases {
		t.Run(testCase.name, func(t *testing.T) {
			stubService := newStubService()
			request := fakeUserUpdate()
			withClient(stubService, func(client userspb.UsersClient) {
				stubService.updateUser = func(ctx context.Context, _ user.Update) (usr user.User, err error) {
					return usr, testCase.result
				}

				_, err := client.UpdateUser(context.Background(), &request)
				require.Equal(t, testCase.expectedCode.String(), status.Code(err).String())
			})
		})
	}
}

func TestDeleteUserRPCCallsUsersServiceAndRespondsWithCorrectValues(t *testing.T) {
	stubService := newStubService()
	request := fakeUserRef()
	withClient(stubService, func(client userspb.UsersClient) {
		// check that the request payload has been conveyed correctly to the users service
		stubService.deleteUser = func(ctx context.Context, ref user.Ref) error {
			require.Equal(t, request.Id, ref.ID)
			return nil
		}

		_, err := client.DeleteUser(context.Background(), &request)
		require.NoError(t, err)
	})
}

func TestCorrectErrorCodesSentDeletingUser(t *testing.T) {
	// For the sake of brevity, I am only going to use grpc error codes when the service fails.
	// In a real world implementation I would, where appropriate, include detail via status details
	cases := []struct {
		name         string
		result       error
		expectedCode codes.Code
	}{
		{
			name:         "NotFound",
			result:       user.ErrNotFound,
			expectedCode: codes.NotFound,
		},
		{
			name:         "Invalid", // invalid could be returned if the id is malformed and cannot be parsed as a UUID
			result:       user.ErrInvalid,
			expectedCode: codes.InvalidArgument,
		},
		{
			name:         "Internal",
			result:       errors.New("some unexpected error"),
			expectedCode: codes.Internal,
		},
	}
	for _, testCase := range cases {
		t.Run(testCase.name, func(t *testing.T) {
			stubService := newStubService()
			request := fakeUserRef()
			withClient(stubService, func(client userspb.UsersClient) {
				stubService.deleteUser = func(ctx context.Context, _ user.Ref) error {
					return testCase.result
				}

				_, err := client.DeleteUser(context.Background(), &request)
				require.Equal(t, testCase.expectedCode.String(), status.Code(err).String())
			})
		})
	}
}

func TestFindUsersRPCCallsServiceAndRespondsWithCorrectValues(t *testing.T) {
	stubService := newStubService()
	request := fakeUsersQuery()
	var response user.Page
	withClient(stubService, func(client userspb.UsersClient) {
		// check that the request payload has been conveyed correctly to the users service
		stubService.findUsers = func(ctx context.Context, query user.Query) (user.Page, error) {
			require.Equal(t, request.CreatedAfter, query.CreatedAfter)
			require.Equal(t, request.Country, query.Country)
			require.Equal(t, request.Page, query.Page)
			require.Equal(t, request.Length, query.Length)

			response = usersPageFromQuery(query)
			return response, nil
		}

		// check that the Page has been correctly conveyed by the RPC
		page, err := client.FindUsers(context.Background(), &request)
		require.NoError(t, err)
		require.Len(t, page.Items, len(response.Items))
		require.Equal(t, page.Total, response.Total)
		for i, itm := range page.Items {
			compareUserToPBUser(t, response.Items[i], itm)
		}
	})
}

func TestCorrectErrorCodeSentFindingUsers(t *testing.T) {
	// For the sake of brevity, I am only going to use grpc error codes when the service fails.
	// In a real world implementation I would, where appropriate, include detail via status details
	stubService := newStubService()
	request := fakeUsersQuery()
	withClient(stubService, func(client userspb.UsersClient) {
		stubService.findUsers = func(ctx context.Context, _ user.Query) (page user.Page, err error) {
			return page, errors.New("some unexpected error")
		}

		_, err := client.FindUsers(context.Background(), &request)
		require.Equal(t, codes.Internal.String(), status.Code(err).String())
	})
}
